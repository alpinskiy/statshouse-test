// Copyright 2024 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package basictl

import (
	"encoding/binary"
	"fmt"
	"io"
	"math"

	"github.com/mailru/easyjson/jlexer"
)

const (
	tinyStringLen    = 253
	bigStringMarker  = 0xfe
	hugeStringMarker = 0xff
	bigStringLen     = (1 << 24) - 1
	hugeStringLen    = (1 << 56) - 1
)

type JsonLexer = jlexer.Lexer

var errBadPadding = fmt.Errorf("non-canonical non-zero string padding")

func CheckLengthSanity(r []byte, natParam uint32, minObjectSize uint32) error {
	if uint64(len(r)) < uint64(natParam)*uint64(minObjectSize) { // Must wrap io.ErrUnexpectedEOF
		return fmt.Errorf("invalid length: %d for remaining reader length: %d and min object size %d: %w", natParam, len(r), minObjectSize, io.ErrUnexpectedEOF)
	}
	return nil
}

func ReadBool(r []byte, v *bool, falseTag uint32, trueTag uint32) ([]byte, error) {
	tag, r, err := NatReadTag(r)
	if err != nil {
		return r, err
	}
	switch tag {
	case falseTag:
		*v = false
	case trueTag:
		*v = true
	default:
		return r, fmt.Errorf("invalid bool tag: 0x%x", tag)
	}
	return r, nil
}

func NatRead(r []byte, dst *uint32) ([]byte, error) {
	if len(r) < 4 {
		return r, io.ErrUnexpectedEOF
	}
	*dst = binary.LittleEndian.Uint32(r)
	return r[4:], nil
}

func NatWrite(w []byte, v uint32) []byte {
	return append(w, byte(v), byte(v>>8), byte(v>>16), byte(v>>24))
}

func nat64Write(w []byte, v uint64) []byte {
	return append(w, byte(v), byte(v>>8), byte(v>>16), byte(v>>24), byte(v>>32), byte(v>>40), byte(v>>48), byte(v>>56))
}

func IntRead(r []byte, dst *int32) ([]byte, error) {
	if len(r) < 4 {
		return r, io.ErrUnexpectedEOF
	}
	*dst = int32(binary.LittleEndian.Uint32(r))
	return r[4:], nil
}

func IntWrite(w []byte, v int32) []byte {
	return append(w, byte(v), byte(v>>8), byte(v>>16), byte(v>>24))
}

func LongRead(r []byte, dst *int64) ([]byte, error) {
	if len(r) < 8 {
		return r, io.ErrUnexpectedEOF
	}
	*dst = int64(binary.LittleEndian.Uint64(r))
	return r[8:], nil
}

func LongWrite(w []byte, v int64) []byte {
	return nat64Write(w, uint64(v))
}

func FloatRead(r []byte, dst *float32) ([]byte, error) {
	if len(r) < 4 {
		return r, io.ErrUnexpectedEOF
	}
	*dst = math.Float32frombits(binary.LittleEndian.Uint32(r))
	return r[4:], nil
}

func FloatWrite(w []byte, v float32) []byte {
	return NatWrite(w, math.Float32bits(v))
}

func DoubleRead(r []byte, dst *float64) ([]byte, error) {
	if len(r) < 8 {
		return r, io.ErrUnexpectedEOF
	}
	*dst = math.Float64frombits(binary.LittleEndian.Uint64(r))
	return r[8:], nil
}

func DoubleWrite(w []byte, v float64) []byte {
	return nat64Write(w, math.Float64bits(v))
}

func StringRead(r []byte, dst *string) ([]byte, error) {
	var b []byte
	r, err := StringReadBytes(r, &b)
	if err != nil {
		return r, err
	}
	*dst = string(b)
	return r, nil
}

func StringReadBytes(r []byte, dst *[]byte) ([]byte, error) {
	if len(r) == 0 {
		return r, io.ErrUnexpectedEOF
	}
	b0 := r[0]

	var l int
	var p int
	switch {
	case b0 <= tinyStringLen:
		l = int(b0)
		r = r[1:]
		p = l + 1
	case b0 == bigStringMarker:
		if len(r) < 4 {
			return r, io.ErrUnexpectedEOF
		}
		l = (int(r[3]) << 16) + (int(r[2]) << 8) + (int(r[1]) << 0)
		r = r[4:]
		p = l // +4
		if l <= tinyStringLen {
			return r, fmt.Errorf("non-canonical (big) string format for length: %d", l)
		}
	default: // hugeStringMarker
		if len(r) < 8 {
			return r, io.ErrUnexpectedEOF
		}
		l64 := (int64(r[7]) << 48) + (int64(r[6]) << 40) + (int64(r[5]) << 32) + (int64(r[4]) << 24) + (int64(r[3]) << 16) + (int64(r[2]) << 8) + (int64(r[1]) << 0)
		if l64 > math.MaxInt {
			return r, fmt.Errorf("string length cannot be represented on 32-bit platform: %d", l64)
		}
		l = int(l64)
		r = r[8:]
		p = l // +8
		if l <= bigStringLen {
			return r, fmt.Errorf("non-canonical (huge) string format for length: %d", l)
		}
	}

	if l > 0 {
		if len(r) < l {
			return r, io.ErrUnexpectedEOF
		}
		// Allocate only after we know there is enough bytes in reader
		if cap(*dst) < l {
			*dst = make([]byte, l)
		} else {
			*dst = (*dst)[:l]
		}
		copy(*dst, r)
	} else {
		*dst = (*dst)[:0]
	}
	padding := paddingLen(p)
	if len(r) < l+padding {
		return r, io.ErrUnexpectedEOF
	}
	for i := 0; i < padding; i++ {
		if r[l+i] != 0 {
			return r, errBadPadding
		}
	}
	return r[l+padding:], nil
}

func NatPeekTag(r []byte) (uint32, error) {
	if len(r) < 4 {
		return 0, io.ErrUnexpectedEOF
	}
	return binary.LittleEndian.Uint32(r), nil
}

func NatReadTag(r []byte) (uint32, []byte, error) {
	if len(r) < 4 {
		return 0, r, io.ErrUnexpectedEOF
	}
	return binary.LittleEndian.Uint32(r), r[4:], nil
}

func NatReadExactTag(r []byte, tag uint32) ([]byte, error) {
	if len(r) < 4 {
		return r, io.ErrUnexpectedEOF
	}
	if t := binary.LittleEndian.Uint32(r); t != tag {
		return r, fmt.Errorf("read tag #%08x instead of #%08x", t, tag)
	}
	return r[4:], nil
}

func paddingLen(l int) int {
	return int(-uint(l) % 4)
}

func StringWrite(w []byte, v string) []byte {
	l := int64(len(v))
	var p int64
	switch {
	case l <= tinyStringLen:
		w = append(w, byte(l))
		p = l + 1
	case l <= bigStringLen:
		w = append(w, bigStringMarker, byte(l), byte(l>>8), byte(l>>16))
		p = l // +4
	default:
		if l > hugeStringLen { // for correctness only, we do not expect strings so huge
			l = hugeStringLen
			v = v[:l]
		}
		w = append(w, hugeStringMarker, byte(l), byte(l>>8), byte(l>>16), byte(l>>24), byte(l>>32), byte(l>>40), byte(l>>48))
		p = l // +8
	}
	w = append(w, v...)

	// w is sometimes slice of byte array, so we do not want optimization to always append 3 bytes, then resize.
	switch uint64(p) % 4 {
	case 1:
		w = append(w, 0, 0, 0)
	case 2:
		w = append(w, 0, 0)
	case 3:
		w = append(w, 0)
	}
	return w
}

func StringWriteBytes(w []byte, v []byte) []byte {
	l := int64(len(v))
	var p int64
	switch {
	case l <= tinyStringLen:
		w = append(w, byte(l))
		p = l + 1
	case l <= bigStringLen:
		w = append(w, bigStringMarker, byte(l), byte(l>>8), byte(l>>16))
		p = l // +4
	default:
		if l > hugeStringLen { // for correctness only, we do not expect strings so huge
			l = hugeStringLen
			v = v[:l]
		}
		w = append(w, hugeStringMarker, byte(l), byte(l>>8), byte(l>>16), byte(l>>24), byte(l>>32), byte(l>>40), byte(l>>48))
		p = l // +8
	}
	w = append(w, v...)

	// w is sometimes slice of byte array, so we do not want optimization to always append 3 bytes, then resize.
	switch uint64(p) % 4 {
	case 1:
		w = append(w, 0, 0, 0)
	case 2:
		w = append(w, 0, 0)
	case 3:
		w = append(w, 0)
	}
	return w
}

const (
	binaryJSONStringStart = "{\"base64\":\""
	binaryJSONStringEnd   = "\"}"
)

func alloc(buf []byte, size int) []byte {
	if cap(buf) >= len(buf)+size {
		return buf[:len(buf)+size]
	}
	return append(buf, make([]byte, size)...)
}

type Rand interface {
	Uint32() uint32
	Int31() int32
	Int63() int64
	NormFloat64() float64
}

type RandGenerator struct {
	maxDepth uint32
	curDepth uint32
	r        Rand
}

func NewRandGenerator(r Rand) *RandGenerator {
	const minDepth = 2
	const maxDepth = 5
	return &RandGenerator{
		maxDepth: (r.Uint32() % (maxDepth - minDepth + 1)) + minDepth,
		curDepth: 0,
		r:        r,
	}
}

func (rg *RandGenerator) IncreaseDepth() {
	if rg.curDepth != rg.maxDepth {
		rg.curDepth += 1
	}
}

func (rg *RandGenerator) DecreaseDepth() {
	if rg.curDepth != 0 {
		rg.curDepth -= 1
	}
}

func (rg *RandGenerator) LimitValue(value uint32) uint32 {
	const limit = 1024
	value &= limit - 1
	return value
}

func RandomUint(rg *RandGenerator) uint32 {
	if rg.curDepth >= rg.maxDepth {
		return 0
	}
	const probabilityBits = 20
	const sourceMask = 1<<probabilityBits - 1

	const w0 = 347_488
	const w1to2 = 367_440 + w0
	const w3to4 = 256_080 + w1to2
	const w5to8 = 73_600 + w3to4
	const w9to16 = 3_712 + w5to8
	const w17to24 = 253 + w9to16
	const w25to32 = 3 + w17to24
	// last weight must be equal to 1<<probabilityBits

	source := rg.r.Uint32()
	categoryBits := source & sourceMask
	bitMask := uint32(0)
	if categoryBits < w0 {
		bitMask = 0
	} else if categoryBits < w1to2 {
		bitMask = 1 + (source>>probabilityBits)&0b1
	} else if categoryBits < w3to4 {
		bitMask = 3 + (source>>probabilityBits)&0b1
	} else if categoryBits < w5to8 {
		bitMask = 5 + (source>>probabilityBits)&0b11
	} else if categoryBits < w9to16 {
		bitMask = 9 + (source>>probabilityBits)&0b111
	} else if categoryBits < w17to24 {
		bitMask = 17 + (source>>probabilityBits)&0b111
	} else if categoryBits < w25to32 {
		bitMask = 25 + (source>>probabilityBits)&0b111
	}

	bitMask = (1 << bitMask) - 1

	return rg.r.Uint32() & bitMask
}

func RandomInt(rg *RandGenerator) int32 {
	return rg.r.Int31()
}

func RandomLong(rg *RandGenerator) int64 {
	return rg.r.Int63()
}

func RandomFloat(rg *RandGenerator) float32 {
	return float32(rg.r.NormFloat64())
}

func RandomDouble(rg *RandGenerator) float64 {
	return rg.r.NormFloat64()
}

const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
const lenLetters uint32 = uint32(len(letters))

const RandomNatConstraint = 32

func RandomString(rg *RandGenerator) string {
	res := make([]byte, rg.r.Uint32()%RandomNatConstraint)
	for i := range res {
		res[i] = letters[rg.r.Uint32()%lenLetters]
	}
	return string(res)
}

func RandomStringBytes(rg *RandGenerator) []byte {
	res := make([]byte, rg.r.Uint32()%RandomNatConstraint)
	for i := range res {
		res[i] = letters[rg.r.Uint32()%lenLetters]
	}
	return res
}
